stderr in color

mycommand 2> >(while read line; do echo -e "\e[01;31m$line\e[0m"; done)

in case you run some command in CLI and would like to take read strerr
little bit better, you can use the following command. It's also possible
to grep it if necessary....

What others think

Can this be applied to the shell as well so that you set it once and it
works for all subsequent commands?

This can be made into a function like so:

function red_error { "$@" 2> >(while read line; do echo -e
"\e[01;31m$line\e[0m"; done) }

Then for example:

red_error tar tvf some_file.tgz

Enter the function and the following into your .bashrc.

bind 'RETURN: "\e[1~error \e[4~\n"'

replace 'error' with the name of the function, in 'dstahlke''s case
'red_error'

Hmm, it seems to interfere with 'read'

It won't die when you hit Ctrl-C. You have to kill a bash process which is
a child of the command being run...

Another odd option:

exec 3> >(while read line; do echo -e "\e[01;31m$line\e[0m"; done)
some_command 2>&3

stderr from some_command will be displayed in red. This opens file handle
#3 and pipes it to the subshell until that file handle is closed with exec
3>&-

Note that doing:

exec 2> >(while read line; do echo -e "\e[01;31m$line\e[0m"; done)

Will make the shell do exectly what is wanted. all stderr displays in red
and stdout displays normally for the shell and commands executed in the
shell. Unfortunately is also has the effect of not displaying the prompt
and any input until input is completed. Anyone know how to get around
this?

intercept stdout/stderr of another process

Terminal - intercept stdout/stderr of another process
strace -ff -e trace=write -e write=1,2 -p SOME_PID

User: oernii2
intercept stdout/stderr of another process



strace -ff -e write=1,2 -s 1024 -p PID 2>&1 | grep "^ |" | cut -c11-60 |
sed -e 's/ //g' | xxd -r -p

User: systemj
intercept stdout/stderr of another process

similar to the previous command, but with more friendly output (tested on
linux)

strace -e write=1,2 -p $PID 2>&1 | sed -un "/^ |/p" | sed -ue
"s/^.\{9\}\(.\{50\}\).\+/\1/g" -e 's/ //g' | xxd -r -p

 { i=0; while sleep 1; do echo -e "writing a long line to stdout 1 [AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA] 2 [BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB] 3 [CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC] \nline2 == var i=$((i++))";done; } > /dev/null & PID=$!

User: glaudiston
intercept stdout/stderr of another process or disowned process

Useful to recover a output(stdout and stderr) "disown"ed or "nohup"ep
process of other instance of ssh.

With the others options the stdout / stderr is intercepted, but only the
first n chars.

This way we can recover ALL text of stdout or stderr


Brilliant. Works like a charm on RHEL 4.

Comment by slower 9 weeks and 6 days ago


Right-align text in console using pipe like ( command | right )

$ right(){ l="$(cat -)"; s=$(echo -e "$l"| wc -L); echo "$l" | while read
l;do j=$(((s-${#l})));echo "$(while ((j-->0)); do printf "
";done;)$l";done;}; ls --color=none / | right

What others think

Nice, but POSIX wc doesn't have -L. You can use awk instead; just replace
the

wc -L

with

awk ' { if ( length > L ) { L=length} }END{ print L}'

and you're there. Doing this takes the function beyond 255 chars, which
may be a problem (so don't one-line it).

Also worth noting that these don't right-justify the text (within your
terminal window confines). They just right align any lines coming out. So
a single line is still flush-left, and the longest line still begins at
column zero.

Yep...

If you want to define the linesize you can do samething like it:

right(){ l="$(cat -)"; [ -n "$1" ] && s=$1 || s=$(echo -e "$l"| wc -L);
echo "$l" | while read l;do j=$(((s-${#l})));echo "$(while ((j-->0)); do
printf " ";done;)$l";done;}; ls --color=none / | right 150

with this u can pass the linesize as parametter or remove the parametter
and use the max-line-size of input

Seems overly complicated.

right(){ while read;do printf "%${1:-${COLUMNS:-80}}s\n" "$REPLY";done
};ls / | right

@eightmillion, this way is simple, but you lost the alignment by text, you
will have only the column alignment.

and "tput cols" works for me, ${COLUMNS} is not set.

then I think

right(){ while read;do printf "%${1:-$(tput cols)}s\n" "$REPLY";done };ls
/ --color=none | right

more efetive in you example.

tnks for your way.
